[{"title":"爬楼梯","url":"/2026/02/18/%E7%88%AC%E6%A5%BC%E6%A2%AF/","content":"题目描述假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n\n示例示例 1：\n输入：n = 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶\n\n示例 2：\n输入：n = 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶\n\n提示\n1 &lt;= n &lt;= 45\n\n解题思路由于一次只能爬 1 或 2 个台阶，所以爬到第 n 阶的方法数为爬到第 n-1 阶的方法数加上爬到第 n-2 阶的方法数。\n$$dp[n] &#x3D; dp[n-1] + dp[n-2]$$\n初始条件为：\n$$dp[0] &#x3D; 1, dp[1] &#x3D; 1$$\n代码实现class Solution:    def climbStairs(self, n: int) -&gt; int:        if n == 1:            return 1        if n == 2:            return 2        a = 1        b = 2        for _ in range(n-2):            c = a + b            a = b            b = c        return b\n","categories":["LeetCode"],"tags":["动态规划"]},{"title":"势均力敌","url":"/2026/02/17/%E5%8A%BF%E5%9D%87%E5%8A%9B%E6%95%8C/","content":"题目描述用 n&gt;2 个不同的个位数字组成一个 n 位数，显然有 n! 个不同的结果。可以证明，这 n! 个数字可以被分为势均力敌的两组 —— 即平方和相等、且个数也相等的两组。\n本题就请你用程序验证一下这个结论。因为本题是一道简单题，所以规模很小，只考虑 n≤4 的情况。\n\n\n输入格式输入第一行给出正整数 n（2&lt;n≤4），随后一行给出 n 个不同的、在区间 [1, 9] 内的个位数字，其间以空格分隔。\n输出格式将所有组成的 n! 个不同的 n 位数分为平方和相等、且个数也相等的两组。但你只需要输出其中一组就可以了。每个数字占一行，共输出 n!&#x2F;2 行。\n注意：解可能不唯一，输出任何一组解就可以。\n输入样例35 2 1\n\n输出样例125512251\n\n解题思路这道题的核心是生成所有可能的排列，然后找到平方和相等的两组。\n算法步骤\n生成全排列：使用回溯算法生成所有 n! 个不同的 n 位数\n计算平方和：对于每个数字，计算其各位数字的平方和\n回溯搜索：找到平方和相等的两组数字，且每组个数为 n!&#x2F;2\n\n代码实现#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123;    ll n;    cin &gt;&gt; n;    vector&lt;ll&gt; a(n);    for(ll i = 0; i &lt; n; i++)&#123;        cin &gt;&gt; a[i];    &#125;    // vis 数组：标记是否使用过    vector&lt;bool&gt; vis(n, false);    // 结果数组    vector&lt;ll&gt; res;    // 回溯    function&lt;void(ll, ll, vector&lt;bool&gt;)&gt; dfs = [&amp;](ll sum, ll pos,vector&lt;bool&gt; vis) &#123;        // 如果已经处理完所有元素，保存结果        if(pos == n)&#123;            res.push_back(sum);            return;        &#125;        // 选择元素        for(ll i = 0 ;i &lt; n; i++)&#123;            if(!vis[i])&#123;                vis[i] = true; // 标记为已使用                dfs(sum * 10 + a[i], pos + 1, vis); // 递归处理下一个元素                vis[i] = false; // 回退，标记为未使用            &#125;        &#125;    &#125;;    dfs(0, 0, vis);    // 计算所有结果的平方和    ll all = 0;    for(ll i = 0; i &lt; res.size(); i++)&#123;        all += res[i] * res[i];    &#125;    all /= 2;        //  答案    vector&lt;ll&gt;path;    // find 标记是否找到结果    bool find = false;    vector&lt;bool&gt; vis1(res.size(), false);    function&lt;void(ll, ll, vector&lt;bool&gt;, ll)&gt; dfs1 = [&amp;](ll sum, ll pos,vector&lt;bool&gt; vis1, ll start) &#123;        // 如果已经找到结果，直接返回        if(find) return;        // 如果当前和等于目标值，标记找到结果并返回        if (sum == all) &#123;            find = true;            return;        &#125;        if(sum &gt; all)&#123;            return;        &#125;        if(pos == res.size() / 2)&#123;            return;        &#125;        for(ll i = start; i &lt; res.size(); i++)&#123;            if(!vis1[i])&#123;                vis1[i] = true;                path.push_back(res[i]);                dfs1(sum + res[i] * res[i], pos + 1, vis1, i + 1);                if(find) return;                path.pop_back();                vis1[i] = false;            &#125;        &#125;    &#125;;    dfs1(0, 0, vis1, 0);    // 输出结果    for(ll i = 0; i &lt; path.size(); i++)&#123;        cout &lt;&lt; path[i] &lt;&lt; &quot;\\n&quot;;    &#125;    return 0;&#125;\n\n总结通过回溯算法生成所有可能的排列，然后计算平方和，最后使用回溯搜索找到平方和相等的两组数字。这道题的关键是理解如何将问题分解为子问题，以及如何使用回溯算法高效地搜索解空间。\n","categories":["算法题解"],"tags":["回溯","全排列"]}]